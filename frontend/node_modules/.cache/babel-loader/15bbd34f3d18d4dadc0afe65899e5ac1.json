{"ast":null,"code":"import _defineProperty from \"/home/jero/Documentos/IonicReactApp/cursoreact/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _asyncToGenerator from \"/home/jero/Documentos/IonicReactApp/cursoreact/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/home/jero/Documentos/IonicReactApp/cursoreact/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/jero/Documentos/IonicReactApp/cursoreact/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/home/jero/Documentos/IonicReactApp/cursoreact/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/home/jero/Documentos/IonicReactApp/cursoreact/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/jero/Documentos/IonicReactApp/cursoreact/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"/home/jero/Documentos/IonicReactApp/cursoreact/node_modules/@babel/runtime/regenerator/index.js\";\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { HTMLElement, createEvent, h, Host, proxyCustomElement } from '@stencil/core/internal/client';\nimport { b as getIonMode } from './ionic-global.js';\nimport { m as isEndSide } from './helpers.js';\nvar itemSlidingCss = \"ion-item-sliding{display:block;position:relative;width:100%;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}ion-item-sliding .item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.item-sliding-active-slide .item{position:relative;-webkit-transition:-webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:-webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1), -webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);opacity:1;z-index:2;pointer-events:none;will-change:transform}.item-sliding-active-swipe-end .item-options-end .item-option-expandable{padding-left:100%;-ms-flex-order:1;order:1;-webkit-transition-duration:0.6s;transition-duration:0.6s;-webkit-transition-property:padding-left;transition-property:padding-left}[dir=rtl] .item-sliding-active-swipe-end .item-options-end .item-option-expandable,:host-context([dir=rtl]) .item-sliding-active-swipe-end .item-options-end .item-option-expandable{-ms-flex-order:-1;order:-1}.item-sliding-active-swipe-start .item-options-start .item-option-expandable{padding-right:100%;-ms-flex-order:-1;order:-1;-webkit-transition-duration:0.6s;transition-duration:0.6s;-webkit-transition-property:padding-right;transition-property:padding-right}[dir=rtl] .item-sliding-active-swipe-start .item-options-start .item-option-expandable,:host-context([dir=rtl]) .item-sliding-active-swipe-start .item-options-start .item-option-expandable{-ms-flex-order:1;order:1}\";\nvar SWIPE_MARGIN = 30;\nvar ELASTIC_FACTOR = 0.55;\nvar openSlidingItem;\n\nvar ItemSliding = /*#__PURE__*/function (_HTMLElement) {\n  _inherits(ItemSliding, _HTMLElement);\n\n  var _super = _createSuper(ItemSliding);\n\n  function ItemSliding() {\n    var _this;\n\n    _classCallCheck(this, ItemSliding);\n\n    _this = _super.call(this);\n\n    _this.__registerHost();\n\n    _this.ionDrag = createEvent(_assertThisInitialized(_this), \"ionDrag\", 7);\n    _this.item = null;\n    _this.openAmount = 0;\n    _this.initialOpenAmount = 0;\n    _this.optsWidthRightSide = 0;\n    _this.optsWidthLeftSide = 0;\n    _this.sides = 0\n    /* None */\n    ;\n    _this.optsDirty = true;\n    _this.closestContent = null;\n    _this.initialContentScrollY = true;\n    _this.state = 2\n    /* Disabled */\n    ;\n    /**\n     * If `true`, the user cannot interact with the sliding item.\n     */\n\n    _this.disabled = false;\n    return _this;\n  }\n\n  _createClass(ItemSliding, [{\n    key: \"disabledChanged\",\n    value: function disabledChanged() {\n      if (this.gesture) {\n        this.gesture.enable(!this.disabled);\n      }\n    }\n  }, {\n    key: \"connectedCallback\",\n    value: function () {\n      var _connectedCallback = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.item = this.el.querySelector('ion-item');\n                this.closestContent = this.el.closest('ion-content');\n                _context.next = 4;\n                return this.updateOptions();\n\n              case 4:\n                _context.next = 6;\n                return import('./index2.js');\n\n              case 6:\n                this.gesture = _context.sent.createGesture({\n                  el: this.el,\n                  gestureName: 'item-swipe',\n                  gesturePriority: 100,\n                  threshold: 5,\n                  canStart: function canStart(ev) {\n                    return _this2.canStart(ev);\n                  },\n                  onStart: function onStart() {\n                    return _this2.onStart();\n                  },\n                  onMove: function onMove(ev) {\n                    return _this2.onMove(ev);\n                  },\n                  onEnd: function onEnd(ev) {\n                    return _this2.onEnd(ev);\n                  }\n                });\n                this.disabledChanged();\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function connectedCallback() {\n        return _connectedCallback.apply(this, arguments);\n      }\n\n      return connectedCallback;\n    }()\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      if (this.gesture) {\n        this.gesture.destroy();\n        this.gesture = undefined;\n      }\n\n      this.item = null;\n      this.leftOptions = this.rightOptions = undefined;\n\n      if (openSlidingItem === this.el) {\n        openSlidingItem = undefined;\n      }\n    }\n    /**\n     * Get the amount the item is open in pixels.\n     */\n\n  }, {\n    key: \"getOpenAmount\",\n    value: function getOpenAmount() {\n      return Promise.resolve(this.openAmount);\n    }\n    /**\n     * Get the ratio of the open amount of the item compared to the width of the options.\n     * If the number returned is positive, then the options on the right side are open.\n     * If the number returned is negative, then the options on the left side are open.\n     * If the absolute value of the number is greater than 1, the item is open more than\n     * the width of the options.\n     */\n\n  }, {\n    key: \"getSlidingRatio\",\n    value: function getSlidingRatio() {\n      return Promise.resolve(this.getSlidingRatioSync());\n    }\n    /**\n     * Open the sliding item.\n     *\n     * @param side The side of the options to open. If a side is not provided, it will open the first set of options it finds within the item.\n     */\n\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(side) {\n        var _this3 = this;\n\n        var optionsToOpen, isStartOpen, isEndOpen;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.item === null)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                optionsToOpen = this.getOptions(side);\n\n                if (optionsToOpen) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 5:\n                /**\n                 * If side is not set, we need to infer the side\n                 * so we know which direction to move the options\n                 */\n                if (side === undefined) {\n                  side = optionsToOpen === this.leftOptions ? 'start' : 'end';\n                } // In RTL we want to switch the sides\n\n\n                side = isEndSide(side) ? 'end' : 'start';\n                isStartOpen = this.openAmount < 0;\n                isEndOpen = this.openAmount > 0;\n                /**\n                 * If a side is open and a user tries to\n                 * re-open the same side, we should not do anything\n                 */\n\n                if (!(isStartOpen && optionsToOpen === this.leftOptions)) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 11:\n                if (!(isEndOpen && optionsToOpen === this.rightOptions)) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 13:\n                this.closeOpened();\n                this.state = 4\n                /* Enabled */\n                ;\n                requestAnimationFrame(function () {\n                  _this3.calculateOptsWidth();\n\n                  var width = side === 'end' ? _this3.optsWidthRightSide : -_this3.optsWidthLeftSide;\n                  openSlidingItem = _this3.el;\n\n                  _this3.setOpenAmount(width, false);\n\n                  _this3.state = side === 'end' ? 8\n                  /* End */\n                  : 16\n                  /* Start */\n                  ;\n                });\n\n              case 16:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function open(_x) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n    /**\n     * Close the sliding item. Items can also be closed from the [List](../list).\n     */\n\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this.setOpenAmount(0, true);\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n    /**\n     * Close all of the sliding items in the list. Items can also be closed from the [List](../list).\n     */\n\n  }, {\n    key: \"closeOpened\",\n    value: function () {\n      var _closeOpened = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(openSlidingItem !== undefined)) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                openSlidingItem.close();\n                openSlidingItem = undefined;\n                return _context4.abrupt(\"return\", true);\n\n              case 4:\n                return _context4.abrupt(\"return\", false);\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function closeOpened() {\n        return _closeOpened.apply(this, arguments);\n      }\n\n      return closeOpened;\n    }()\n    /**\n     * Given an optional side, return the ion-item-options element.\n     *\n     * @param side This side of the options to get. If a side is not provided it will\n     * return the first one available.\n     */\n\n  }, {\n    key: \"getOptions\",\n    value: function getOptions(side) {\n      if (side === undefined) {\n        return this.leftOptions || this.rightOptions;\n      } else if (side === 'start') {\n        return this.leftOptions;\n      } else {\n        return this.rightOptions;\n      }\n    }\n  }, {\n    key: \"updateOptions\",\n    value: function () {\n      var _updateOptions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var options, sides, i, item, option, side;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                options = this.el.querySelectorAll('ion-item-options');\n                sides = 0; // Reset left and right options in case they were removed\n\n                this.leftOptions = this.rightOptions = undefined;\n                i = 0;\n\n              case 4:\n                if (!(i < options.length)) {\n                  _context5.next = 19;\n                  break;\n                }\n\n                item = options.item(i);\n                /**\n                 * We cannot use the componentOnReady helper\n                 * util here since we need to wait for all of these items\n                 * to be ready before we set `this.sides` and `this.optsDirty`.\n                 */\n\n                if (!(item.componentOnReady !== undefined)) {\n                  _context5.next = 12;\n                  break;\n                }\n\n                _context5.next = 9;\n                return item.componentOnReady();\n\n              case 9:\n                _context5.t0 = _context5.sent;\n                _context5.next = 13;\n                break;\n\n              case 12:\n                _context5.t0 = item;\n\n              case 13:\n                option = _context5.t0;\n                side = isEndSide(option.side) ? 'end' : 'start';\n\n                if (side === 'start') {\n                  this.leftOptions = option;\n                  sides |= 1\n                  /* Start */\n                  ;\n                } else {\n                  this.rightOptions = option;\n                  sides |= 2\n                  /* End */\n                  ;\n                }\n\n              case 16:\n                i++;\n                _context5.next = 4;\n                break;\n\n              case 19:\n                this.optsDirty = true;\n                this.sides = sides;\n\n              case 21:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function updateOptions() {\n        return _updateOptions.apply(this, arguments);\n      }\n\n      return updateOptions;\n    }()\n  }, {\n    key: \"canStart\",\n    value: function canStart(gesture) {\n      /**\n       * If very close to start of the screen\n       * do not open left side so swipe to go\n       * back will still work.\n       */\n      var rtl = document.dir === 'rtl';\n      var atEdge = rtl ? window.innerWidth - gesture.startX < 15 : gesture.startX < 15;\n\n      if (atEdge) {\n        return false;\n      }\n\n      var selected = openSlidingItem;\n\n      if (selected && selected !== this.el) {\n        this.closeOpened();\n      }\n\n      return !!(this.rightOptions || this.leftOptions);\n    }\n  }, {\n    key: \"disableContentScrollY\",\n    value: function disableContentScrollY() {\n      if (this.closestContent === null) {\n        return;\n      }\n\n      this.initialContentScrollY = this.closestContent.scrollY;\n      this.closestContent.scrollY = false;\n    }\n  }, {\n    key: \"restoreContentScrollY\",\n    value: function restoreContentScrollY() {\n      if (this.closestContent === null) {\n        return;\n      }\n\n      this.closestContent.scrollY = this.initialContentScrollY;\n    }\n  }, {\n    key: \"onStart\",\n    value: function onStart() {\n      /**\n       * We need to query for the ion-item\n       * every time the gesture starts. Developers\n       * may toggle ion-item elements via *ngIf.\n       */\n      this.item = this.el.querySelector('ion-item'); // Prevent scrolling during gesture\n\n      this.disableContentScrollY();\n      openSlidingItem = this.el;\n\n      if (this.tmr !== undefined) {\n        clearTimeout(this.tmr);\n        this.tmr = undefined;\n      }\n\n      if (this.openAmount === 0) {\n        this.optsDirty = true;\n        this.state = 4\n        /* Enabled */\n        ;\n      }\n\n      this.initialOpenAmount = this.openAmount;\n\n      if (this.item) {\n        this.item.style.transition = 'none';\n      }\n    }\n  }, {\n    key: \"onMove\",\n    value: function onMove(gesture) {\n      if (this.optsDirty) {\n        this.calculateOptsWidth();\n      }\n\n      var openAmount = this.initialOpenAmount - gesture.deltaX;\n\n      switch (this.sides) {\n        case 2\n        /* End */\n        :\n          openAmount = Math.max(0, openAmount);\n          break;\n\n        case 1\n        /* Start */\n        :\n          openAmount = Math.min(0, openAmount);\n          break;\n\n        case 3\n        /* Both */\n        :\n          break;\n\n        case 0\n        /* None */\n        :\n          return;\n\n        default:\n          console.warn('invalid ItemSideFlags value', this.sides);\n          break;\n      }\n\n      var optsWidth;\n\n      if (openAmount > this.optsWidthRightSide) {\n        optsWidth = this.optsWidthRightSide;\n        openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;\n      } else if (openAmount < -this.optsWidthLeftSide) {\n        optsWidth = -this.optsWidthLeftSide;\n        openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;\n      }\n\n      this.setOpenAmount(openAmount, false);\n    }\n  }, {\n    key: \"onEnd\",\n    value: function onEnd(gesture) {\n      // Restore ion-content scrollY to initial value when gesture ends\n      this.restoreContentScrollY();\n      var velocity = gesture.velocityX;\n      var restingPoint = this.openAmount > 0 ? this.optsWidthRightSide : -this.optsWidthLeftSide; // Check if the drag didn't clear the buttons mid-point\n      // and we aren't moving fast enough to swipe open\n\n      var isResetDirection = this.openAmount > 0 === !(velocity < 0);\n      var isMovingFast = Math.abs(velocity) > 0.3;\n      var isOnCloseZone = Math.abs(this.openAmount) < Math.abs(restingPoint / 2);\n\n      if (swipeShouldReset(isResetDirection, isMovingFast, isOnCloseZone)) {\n        restingPoint = 0;\n      }\n\n      var state = this.state;\n      this.setOpenAmount(restingPoint, true);\n\n      if ((state & 32\n      /* SwipeEnd */\n      ) !== 0 && this.rightOptions) {\n        this.rightOptions.fireSwipeEvent();\n      } else if ((state & 64\n      /* SwipeStart */\n      ) !== 0 && this.leftOptions) {\n        this.leftOptions.fireSwipeEvent();\n      }\n    }\n  }, {\n    key: \"calculateOptsWidth\",\n    value: function calculateOptsWidth() {\n      this.optsWidthRightSide = 0;\n\n      if (this.rightOptions) {\n        this.rightOptions.style.display = 'flex';\n        this.optsWidthRightSide = this.rightOptions.offsetWidth;\n        this.rightOptions.style.display = '';\n      }\n\n      this.optsWidthLeftSide = 0;\n\n      if (this.leftOptions) {\n        this.leftOptions.style.display = 'flex';\n        this.optsWidthLeftSide = this.leftOptions.offsetWidth;\n        this.leftOptions.style.display = '';\n      }\n\n      this.optsDirty = false;\n    }\n  }, {\n    key: \"setOpenAmount\",\n    value: function setOpenAmount(openAmount, isFinal) {\n      var _this4 = this;\n\n      if (this.tmr !== undefined) {\n        clearTimeout(this.tmr);\n        this.tmr = undefined;\n      }\n\n      if (!this.item) {\n        return;\n      }\n\n      var style = this.item.style;\n      this.openAmount = openAmount;\n\n      if (isFinal) {\n        style.transition = '';\n      }\n\n      if (openAmount > 0) {\n        this.state = openAmount >= this.optsWidthRightSide + SWIPE_MARGIN ? 8\n        /* End */\n        | 32\n        /* SwipeEnd */\n        : 8\n        /* End */\n        ;\n      } else if (openAmount < 0) {\n        this.state = openAmount <= -this.optsWidthLeftSide - SWIPE_MARGIN ? 16\n        /* Start */\n        | 64\n        /* SwipeStart */\n        : 16\n        /* Start */\n        ;\n      } else {\n        /**\n         * Item sliding cannot be interrupted\n         * while closing the item. If it did,\n         * it would allow the item to get into an\n         * inconsistent state where multiple\n         * items are then open at the same time.\n         */\n        if (this.gesture) {\n          this.gesture.enable(false);\n        }\n\n        this.tmr = setTimeout(function () {\n          _this4.state = 2\n          /* Disabled */\n          ;\n          _this4.tmr = undefined;\n\n          if (_this4.gesture) {\n            _this4.gesture.enable(true);\n          }\n        }, 600);\n        openSlidingItem = undefined;\n        style.transform = '';\n        return;\n      }\n\n      style.transform = \"translate3d(\".concat(-openAmount, \"px,0,0)\");\n      this.ionDrag.emit({\n        amount: openAmount,\n        ratio: this.getSlidingRatioSync()\n      });\n    }\n  }, {\n    key: \"getSlidingRatioSync\",\n    value: function getSlidingRatioSync() {\n      if (this.openAmount > 0) {\n        return this.openAmount / this.optsWidthRightSide;\n      } else if (this.openAmount < 0) {\n        return this.openAmount / this.optsWidthLeftSide;\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _class;\n\n      var mode = getIonMode(this);\n      return h(Host, {\n        class: (_class = {}, _defineProperty(_class, mode, true), _defineProperty(_class, 'item-sliding-active-slide', this.state !== 2\n        /* Disabled */\n        ), _defineProperty(_class, 'item-sliding-active-options-end', (this.state & 8\n        /* End */\n        ) !== 0), _defineProperty(_class, 'item-sliding-active-options-start', (this.state & 16\n        /* Start */\n        ) !== 0), _defineProperty(_class, 'item-sliding-active-swipe-end', (this.state & 32\n        /* SwipeEnd */\n        ) !== 0), _defineProperty(_class, 'item-sliding-active-swipe-start', (this.state & 64\n        /* SwipeStart */\n        ) !== 0), _class)\n      });\n    }\n  }, {\n    key: \"el\",\n    get: function get() {\n      return this;\n    }\n  }], [{\n    key: \"watchers\",\n    get: function get() {\n      return {\n        \"disabled\": [\"disabledChanged\"]\n      };\n    }\n  }, {\n    key: \"style\",\n    get: function get() {\n      return itemSlidingCss;\n    }\n  }]);\n\n  return ItemSliding;\n}(HTMLElement);\n\nvar swipeShouldReset = function swipeShouldReset(isResetDirection, isMovingFast, isOnResetZone) {\n  // The logic required to know when the sliding item should close (openAmount=0)\n  // depends on three booleans (isResetDirection, isMovingFast, isOnResetZone)\n  // and it ended up being too complicated to be written manually without errors\n  // so the truth table is attached below: (0=false, 1=true)\n  // isResetDirection | isMovingFast | isOnResetZone || shouldClose\n  //         0        |       0      |       0       ||    0\n  //         0        |       0      |       1       ||    1\n  //         0        |       1      |       0       ||    0\n  //         0        |       1      |       1       ||    0\n  //         1        |       0      |       0       ||    0\n  //         1        |       0      |       1       ||    1\n  //         1        |       1      |       0       ||    1\n  //         1        |       1      |       1       ||    1\n  // The resulting expression was generated by resolving the K-map (Karnaugh map):\n  return !isMovingFast && isOnResetZone || isResetDirection && isMovingFast;\n};\n\nItemSliding = /*@__PURE__*/proxyCustomElement(ItemSliding, [0, \"ion-item-sliding\", {\n  \"disabled\": [4],\n  \"state\": [32],\n  \"getOpenAmount\": [64],\n  \"getSlidingRatio\": [64],\n  \"open\": [64],\n  \"close\": [64],\n  \"closeOpened\": [64]\n}]);\n\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n\n  var components = [\"ion-item-sliding\"];\n  components.forEach(function (tagName) {\n    switch (tagName) {\n      case \"ion-item-sliding\":\n        if (!customElements.get(tagName)) {\n          customElements.define(tagName, ItemSliding);\n        }\n\n        break;\n    }\n  });\n}\n\nvar IonItemSliding = ItemSliding;\nvar defineCustomElement = defineCustomElement$1;\nexport { IonItemSliding, defineCustomElement };","map":{"version":3,"sources":["/home/jero/Documentos/IonicReactApp/cursoreact/node_modules/@ionic/core/components/ion-item-sliding.js"],"names":["HTMLElement","createEvent","h","Host","proxyCustomElement","b","getIonMode","m","isEndSide","itemSlidingCss","SWIPE_MARGIN","ELASTIC_FACTOR","openSlidingItem","ItemSliding","__registerHost","ionDrag","item","openAmount","initialOpenAmount","optsWidthRightSide","optsWidthLeftSide","sides","optsDirty","closestContent","initialContentScrollY","state","disabled","gesture","enable","el","querySelector","closest","updateOptions","createGesture","gestureName","gesturePriority","threshold","canStart","ev","onStart","onMove","onEnd","disabledChanged","destroy","undefined","leftOptions","rightOptions","Promise","resolve","getSlidingRatioSync","side","optionsToOpen","getOptions","isStartOpen","isEndOpen","closeOpened","requestAnimationFrame","calculateOptsWidth","width","setOpenAmount","close","options","querySelectorAll","i","length","componentOnReady","option","rtl","document","dir","atEdge","window","innerWidth","startX","selected","scrollY","disableContentScrollY","tmr","clearTimeout","style","transition","deltaX","Math","max","min","console","warn","optsWidth","restoreContentScrollY","velocity","velocityX","restingPoint","isResetDirection","isMovingFast","abs","isOnCloseZone","swipeShouldReset","fireSwipeEvent","display","offsetWidth","isFinal","setTimeout","transform","emit","amount","ratio","mode","class","isOnResetZone","defineCustomElement$1","customElements","components","forEach","tagName","get","define","IonItemSliding","defineCustomElement"],"mappings":"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","sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { HTMLElement, createEvent, h, Host, proxyCustomElement } from '@stencil/core/internal/client';\nimport { b as getIonMode } from './ionic-global.js';\nimport { m as isEndSide } from './helpers.js';\n\nconst itemSlidingCss = \"ion-item-sliding{display:block;position:relative;width:100%;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}ion-item-sliding .item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.item-sliding-active-slide .item{position:relative;-webkit-transition:-webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:-webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1), -webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);opacity:1;z-index:2;pointer-events:none;will-change:transform}.item-sliding-active-swipe-end .item-options-end .item-option-expandable{padding-left:100%;-ms-flex-order:1;order:1;-webkit-transition-duration:0.6s;transition-duration:0.6s;-webkit-transition-property:padding-left;transition-property:padding-left}[dir=rtl] .item-sliding-active-swipe-end .item-options-end .item-option-expandable,:host-context([dir=rtl]) .item-sliding-active-swipe-end .item-options-end .item-option-expandable{-ms-flex-order:-1;order:-1}.item-sliding-active-swipe-start .item-options-start .item-option-expandable{padding-right:100%;-ms-flex-order:-1;order:-1;-webkit-transition-duration:0.6s;transition-duration:0.6s;-webkit-transition-property:padding-right;transition-property:padding-right}[dir=rtl] .item-sliding-active-swipe-start .item-options-start .item-option-expandable,:host-context([dir=rtl]) .item-sliding-active-swipe-start .item-options-start .item-option-expandable{-ms-flex-order:1;order:1}\";\n\nconst SWIPE_MARGIN = 30;\nconst ELASTIC_FACTOR = 0.55;\nlet openSlidingItem;\nlet ItemSliding = class extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.ionDrag = createEvent(this, \"ionDrag\", 7);\n    this.item = null;\n    this.openAmount = 0;\n    this.initialOpenAmount = 0;\n    this.optsWidthRightSide = 0;\n    this.optsWidthLeftSide = 0;\n    this.sides = 0 /* None */;\n    this.optsDirty = true;\n    this.closestContent = null;\n    this.initialContentScrollY = true;\n    this.state = 2 /* Disabled */;\n    /**\n     * If `true`, the user cannot interact with the sliding item.\n     */\n    this.disabled = false;\n  }\n  disabledChanged() {\n    if (this.gesture) {\n      this.gesture.enable(!this.disabled);\n    }\n  }\n  async connectedCallback() {\n    this.item = this.el.querySelector('ion-item');\n    this.closestContent = this.el.closest('ion-content');\n    await this.updateOptions();\n    this.gesture = (await import('./index2.js')).createGesture({\n      el: this.el,\n      gestureName: 'item-swipe',\n      gesturePriority: 100,\n      threshold: 5,\n      canStart: ev => this.canStart(ev),\n      onStart: () => this.onStart(),\n      onMove: ev => this.onMove(ev),\n      onEnd: ev => this.onEnd(ev),\n    });\n    this.disabledChanged();\n  }\n  disconnectedCallback() {\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n    this.item = null;\n    this.leftOptions = this.rightOptions = undefined;\n    if (openSlidingItem === this.el) {\n      openSlidingItem = undefined;\n    }\n  }\n  /**\n   * Get the amount the item is open in pixels.\n   */\n  getOpenAmount() {\n    return Promise.resolve(this.openAmount);\n  }\n  /**\n   * Get the ratio of the open amount of the item compared to the width of the options.\n   * If the number returned is positive, then the options on the right side are open.\n   * If the number returned is negative, then the options on the left side are open.\n   * If the absolute value of the number is greater than 1, the item is open more than\n   * the width of the options.\n   */\n  getSlidingRatio() {\n    return Promise.resolve(this.getSlidingRatioSync());\n  }\n  /**\n   * Open the sliding item.\n   *\n   * @param side The side of the options to open. If a side is not provided, it will open the first set of options it finds within the item.\n   */\n  async open(side) {\n    if (this.item === null) {\n      return;\n    }\n    const optionsToOpen = this.getOptions(side);\n    if (!optionsToOpen) {\n      return;\n    }\n    /**\n     * If side is not set, we need to infer the side\n     * so we know which direction to move the options\n     */\n    if (side === undefined) {\n      side = (optionsToOpen === this.leftOptions) ? 'start' : 'end';\n    }\n    // In RTL we want to switch the sides\n    side = isEndSide(side) ? 'end' : 'start';\n    const isStartOpen = this.openAmount < 0;\n    const isEndOpen = this.openAmount > 0;\n    /**\n     * If a side is open and a user tries to\n     * re-open the same side, we should not do anything\n     */\n    if (isStartOpen && optionsToOpen === this.leftOptions) {\n      return;\n    }\n    if (isEndOpen && optionsToOpen === this.rightOptions) {\n      return;\n    }\n    this.closeOpened();\n    this.state = 4 /* Enabled */;\n    requestAnimationFrame(() => {\n      this.calculateOptsWidth();\n      const width = (side === 'end') ? this.optsWidthRightSide : -this.optsWidthLeftSide;\n      openSlidingItem = this.el;\n      this.setOpenAmount(width, false);\n      this.state = (side === 'end') ? 8 /* End */ : 16 /* Start */;\n    });\n  }\n  /**\n   * Close the sliding item. Items can also be closed from the [List](../list).\n   */\n  async close() {\n    this.setOpenAmount(0, true);\n  }\n  /**\n   * Close all of the sliding items in the list. Items can also be closed from the [List](../list).\n   */\n  async closeOpened() {\n    if (openSlidingItem !== undefined) {\n      openSlidingItem.close();\n      openSlidingItem = undefined;\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Given an optional side, return the ion-item-options element.\n   *\n   * @param side This side of the options to get. If a side is not provided it will\n   * return the first one available.\n   */\n  getOptions(side) {\n    if (side === undefined) {\n      return this.leftOptions || this.rightOptions;\n    }\n    else if (side === 'start') {\n      return this.leftOptions;\n    }\n    else {\n      return this.rightOptions;\n    }\n  }\n  async updateOptions() {\n    const options = this.el.querySelectorAll('ion-item-options');\n    let sides = 0;\n    // Reset left and right options in case they were removed\n    this.leftOptions = this.rightOptions = undefined;\n    for (let i = 0; i < options.length; i++) {\n      const item = options.item(i);\n      /**\n       * We cannot use the componentOnReady helper\n       * util here since we need to wait for all of these items\n       * to be ready before we set `this.sides` and `this.optsDirty`.\n       */\n      const option = (item.componentOnReady !== undefined) ? await item.componentOnReady() : item;\n      const side = isEndSide(option.side) ? 'end' : 'start';\n      if (side === 'start') {\n        this.leftOptions = option;\n        sides |= 1 /* Start */;\n      }\n      else {\n        this.rightOptions = option;\n        sides |= 2 /* End */;\n      }\n    }\n    this.optsDirty = true;\n    this.sides = sides;\n  }\n  canStart(gesture) {\n    /**\n     * If very close to start of the screen\n     * do not open left side so swipe to go\n     * back will still work.\n     */\n    const rtl = document.dir === 'rtl';\n    const atEdge = (rtl) ? (window.innerWidth - gesture.startX) < 15 : gesture.startX < 15;\n    if (atEdge) {\n      return false;\n    }\n    const selected = openSlidingItem;\n    if (selected && selected !== this.el) {\n      this.closeOpened();\n    }\n    return !!(this.rightOptions || this.leftOptions);\n  }\n  disableContentScrollY() {\n    if (this.closestContent === null) {\n      return;\n    }\n    this.initialContentScrollY = this.closestContent.scrollY;\n    this.closestContent.scrollY = false;\n  }\n  restoreContentScrollY() {\n    if (this.closestContent === null) {\n      return;\n    }\n    this.closestContent.scrollY = this.initialContentScrollY;\n  }\n  onStart() {\n    /**\n     * We need to query for the ion-item\n     * every time the gesture starts. Developers\n     * may toggle ion-item elements via *ngIf.\n     */\n    this.item = this.el.querySelector('ion-item');\n    // Prevent scrolling during gesture\n    this.disableContentScrollY();\n    openSlidingItem = this.el;\n    if (this.tmr !== undefined) {\n      clearTimeout(this.tmr);\n      this.tmr = undefined;\n    }\n    if (this.openAmount === 0) {\n      this.optsDirty = true;\n      this.state = 4 /* Enabled */;\n    }\n    this.initialOpenAmount = this.openAmount;\n    if (this.item) {\n      this.item.style.transition = 'none';\n    }\n  }\n  onMove(gesture) {\n    if (this.optsDirty) {\n      this.calculateOptsWidth();\n    }\n    let openAmount = this.initialOpenAmount - gesture.deltaX;\n    switch (this.sides) {\n      case 2 /* End */:\n        openAmount = Math.max(0, openAmount);\n        break;\n      case 1 /* Start */:\n        openAmount = Math.min(0, openAmount);\n        break;\n      case 3 /* Both */: break;\n      case 0 /* None */: return;\n      default:\n        console.warn('invalid ItemSideFlags value', this.sides);\n        break;\n    }\n    let optsWidth;\n    if (openAmount > this.optsWidthRightSide) {\n      optsWidth = this.optsWidthRightSide;\n      openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;\n    }\n    else if (openAmount < -this.optsWidthLeftSide) {\n      optsWidth = -this.optsWidthLeftSide;\n      openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;\n    }\n    this.setOpenAmount(openAmount, false);\n  }\n  onEnd(gesture) {\n    // Restore ion-content scrollY to initial value when gesture ends\n    this.restoreContentScrollY();\n    const velocity = gesture.velocityX;\n    let restingPoint = (this.openAmount > 0)\n      ? this.optsWidthRightSide\n      : -this.optsWidthLeftSide;\n    // Check if the drag didn't clear the buttons mid-point\n    // and we aren't moving fast enough to swipe open\n    const isResetDirection = (this.openAmount > 0) === !(velocity < 0);\n    const isMovingFast = Math.abs(velocity) > 0.3;\n    const isOnCloseZone = Math.abs(this.openAmount) < Math.abs(restingPoint / 2);\n    if (swipeShouldReset(isResetDirection, isMovingFast, isOnCloseZone)) {\n      restingPoint = 0;\n    }\n    const state = this.state;\n    this.setOpenAmount(restingPoint, true);\n    if ((state & 32 /* SwipeEnd */) !== 0 && this.rightOptions) {\n      this.rightOptions.fireSwipeEvent();\n    }\n    else if ((state & 64 /* SwipeStart */) !== 0 && this.leftOptions) {\n      this.leftOptions.fireSwipeEvent();\n    }\n  }\n  calculateOptsWidth() {\n    this.optsWidthRightSide = 0;\n    if (this.rightOptions) {\n      this.rightOptions.style.display = 'flex';\n      this.optsWidthRightSide = this.rightOptions.offsetWidth;\n      this.rightOptions.style.display = '';\n    }\n    this.optsWidthLeftSide = 0;\n    if (this.leftOptions) {\n      this.leftOptions.style.display = 'flex';\n      this.optsWidthLeftSide = this.leftOptions.offsetWidth;\n      this.leftOptions.style.display = '';\n    }\n    this.optsDirty = false;\n  }\n  setOpenAmount(openAmount, isFinal) {\n    if (this.tmr !== undefined) {\n      clearTimeout(this.tmr);\n      this.tmr = undefined;\n    }\n    if (!this.item) {\n      return;\n    }\n    const style = this.item.style;\n    this.openAmount = openAmount;\n    if (isFinal) {\n      style.transition = '';\n    }\n    if (openAmount > 0) {\n      this.state = (openAmount >= (this.optsWidthRightSide + SWIPE_MARGIN))\n        ? 8 /* End */ | 32 /* SwipeEnd */\n        : 8 /* End */;\n    }\n    else if (openAmount < 0) {\n      this.state = (openAmount <= (-this.optsWidthLeftSide - SWIPE_MARGIN))\n        ? 16 /* Start */ | 64 /* SwipeStart */\n        : 16 /* Start */;\n    }\n    else {\n      /**\n       * Item sliding cannot be interrupted\n       * while closing the item. If it did,\n       * it would allow the item to get into an\n       * inconsistent state where multiple\n       * items are then open at the same time.\n       */\n      if (this.gesture) {\n        this.gesture.enable(false);\n      }\n      this.tmr = setTimeout(() => {\n        this.state = 2 /* Disabled */;\n        this.tmr = undefined;\n        if (this.gesture) {\n          this.gesture.enable(true);\n        }\n      }, 600);\n      openSlidingItem = undefined;\n      style.transform = '';\n      return;\n    }\n    style.transform = `translate3d(${-openAmount}px,0,0)`;\n    this.ionDrag.emit({\n      amount: openAmount,\n      ratio: this.getSlidingRatioSync()\n    });\n  }\n  getSlidingRatioSync() {\n    if (this.openAmount > 0) {\n      return this.openAmount / this.optsWidthRightSide;\n    }\n    else if (this.openAmount < 0) {\n      return this.openAmount / this.optsWidthLeftSide;\n    }\n    else {\n      return 0;\n    }\n  }\n  render() {\n    const mode = getIonMode(this);\n    return (h(Host, { class: {\n        [mode]: true,\n        'item-sliding-active-slide': (this.state !== 2 /* Disabled */),\n        'item-sliding-active-options-end': (this.state & 8 /* End */) !== 0,\n        'item-sliding-active-options-start': (this.state & 16 /* Start */) !== 0,\n        'item-sliding-active-swipe-end': (this.state & 32 /* SwipeEnd */) !== 0,\n        'item-sliding-active-swipe-start': (this.state & 64 /* SwipeStart */) !== 0\n      } }));\n  }\n  get el() { return this; }\n  static get watchers() { return {\n    \"disabled\": [\"disabledChanged\"]\n  }; }\n  static get style() { return itemSlidingCss; }\n};\nconst swipeShouldReset = (isResetDirection, isMovingFast, isOnResetZone) => {\n  // The logic required to know when the sliding item should close (openAmount=0)\n  // depends on three booleans (isResetDirection, isMovingFast, isOnResetZone)\n  // and it ended up being too complicated to be written manually without errors\n  // so the truth table is attached below: (0=false, 1=true)\n  // isResetDirection | isMovingFast | isOnResetZone || shouldClose\n  //         0        |       0      |       0       ||    0\n  //         0        |       0      |       1       ||    1\n  //         0        |       1      |       0       ||    0\n  //         0        |       1      |       1       ||    0\n  //         1        |       0      |       0       ||    0\n  //         1        |       0      |       1       ||    1\n  //         1        |       1      |       0       ||    1\n  //         1        |       1      |       1       ||    1\n  // The resulting expression was generated by resolving the K-map (Karnaugh map):\n  return (!isMovingFast && isOnResetZone) || (isResetDirection && isMovingFast);\n};\nItemSliding = /*@__PURE__*/ proxyCustomElement(ItemSliding, [0, \"ion-item-sliding\", {\n    \"disabled\": [4],\n    \"state\": [32],\n    \"getOpenAmount\": [64],\n    \"getSlidingRatio\": [64],\n    \"open\": [64],\n    \"close\": [64],\n    \"closeOpened\": [64]\n  }]);\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-item-sliding\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-item-sliding\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, ItemSliding);\n      }\n      break;\n  } });\n}\n\nconst IonItemSliding = ItemSliding;\nconst defineCustomElement = defineCustomElement$1;\n\nexport { IonItemSliding, defineCustomElement };\n"]},"metadata":{},"sourceType":"module"}